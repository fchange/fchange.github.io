<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  <meta name="referrer" content="unsafe-url">
  
  <title>什么？Golang的sync不支持重入？</title>
  <meta name="author" content="Fchange">
  <meta name="description" content="life is like a dream">
  
  
  <meta property="og:title" content="什么？Golang的sync不支持重入？"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="Fchange"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="Fchange" type="application/atom+xml">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  
    <div class="description">
      &nbsp;life is like a dream
    </div>
    
</div>


  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        什么？Golang的sync不支持重入？
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2024-03-14T16:00:00.000Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2024-03-15
</time>


    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/categories/随笔/">随笔</a>




    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/tags/技术/">技术</a>


    </div>
    <hr>
    
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0BiMap"><span class="toc-text">实现BiMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">引入线程安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync%E5%8C%85%E7%9A%84%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">sync包的不可重入性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E9%87%8A"><span class="toc-text">官方文档解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">解决不可重入性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81"><span class="toc-text">最终代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A7%81%E8%A7%A3"><span class="toc-text">总结与见解</span></a></li></ol>
    
    <div class="picture-container">
      
    </div>
    <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在进行开发过程中，我们常常会遇到需要使用到一些特定数据结构的情况。最近我遇到了一个需求，需要使用到一个BiMap（或称”双向映射”）的数据结构。遗憾的是，Golang官方并没有提供这样的数据结构。可以作为参考的是 guava 的 <a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap">BiMap</a>。于是，我决定自己动手实现一个。</p>
<p>作为特殊处理，我这里还涉及到 key -&gt; value set， 所以会是一个带逆向的map[K]map[V]struct{}。</p>
<h2 id="实现BiMap"><a href="#实现BiMap" class="headerlink" title="实现BiMap"></a>实现BiMap</h2><p>为了实现这个BiMap，我创建了一个名为BiMap的结构体。该结构体内部持有两个map，分别用于键到值和值到键的映射。这样，我就可以通过键或值来进行快速的双向查找。<br>注意我的实现里用到了泛型。并使用了 comparable 类型约束，这是 Go 1.18 中引入的新特性。如果你使用的是较早版本的 Go，可能需要对类型约束进行适当的修改，或者升级到 Go 1.18 版本以支持 comparable 类型约束。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BiMap[K comparable, V comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	forwardMap  <span class="keyword">map</span>[K]<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	backwardMap <span class="keyword">map</span>[V]K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBiMap</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">comparable</span>]<span class="params">()</span></span> *BiMap[K, V] &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BiMap[K, V]&#123;</span><br><span class="line">		forwardMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[K]<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		backwardMap: <span class="built_in">make</span>(<span class="keyword">map</span>[V]K),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> ResetByKey(key K, values ...V) &#123;</span><br><span class="line">	<span class="comment">// 删除原有关联的键值对</span></span><br><span class="line">	oldValues := bm.GetByKey(key)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> oldValues &#123;</span><br><span class="line">		<span class="built_in">delete</span>(bm.backwardMap, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的关联的键值对</span></span><br><span class="line">	bm.forwardMap[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		bm.forwardMap[key][value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		bm.backwardMap[value] = key</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> ResetByValue(value V, key K) &#123;</span><br><span class="line">	oldKey, ok := bm.GetByValue(value)</span><br><span class="line">	<span class="keyword">if</span> !ok || oldKey == key &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除原有关联的键值对</span></span><br><span class="line">	<span class="built_in">delete</span>(bm.backwardMap, value)</span><br><span class="line">	<span class="built_in">delete</span>(bm.forwardMap[oldKey], value)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bm.forwardMap[oldKey]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(bm.forwardMap, oldKey)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的关联的键值对</span></span><br><span class="line">	bm.backwardMap[value] = key</span><br><span class="line">	<span class="keyword">if</span> _, ok := bm.forwardMap[key]; !ok &#123;</span><br><span class="line">		bm.forwardMap[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	bm.forwardMap[key][value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> GetByKey(key K) []V &#123;</span><br><span class="line">	values, ok := bm.forwardMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]V, <span class="number">0</span>, <span class="built_in">len</span>(values))</span><br><span class="line">	<span class="keyword">for</span> value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> GetByValue(value V) (K, <span class="type">bool</span>) &#123;</span><br><span class="line">	key, ok := bm.backwardMap[value]</span><br><span class="line">	<span class="keyword">return</span> key, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bimap := NewBiMap[<span class="type">string</span>, <span class="type">int</span>]()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加键值对</span></span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;apple&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...)</span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;banana&quot;</span>, []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;...)</span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;cherry&quot;</span>, []<span class="type">int</span>&#123;<span class="number">6</span>&#125;...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取键对应的值</span></span><br><span class="line">	appleValues := bimap.GetByKey(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Values for apple:&quot;</span>, appleValues) <span class="comment">// Output: Values for apple: [1 2 3]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置键对应的值</span></span><br><span class="line">	bimap.ResetByValue(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>)</span><br><span class="line">	updatedAppleValues := bimap.GetByKey(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">	updatedBananaValues := bimap.GetByKey(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Updated values for apple:&quot;</span>, updatedAppleValues)   <span class="comment">// Output: Updated values for apple: [1 3]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Updated values for banana:&quot;</span>, updatedBananaValues) <span class="comment">// Output: Updated values for banana: [4 5 2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的键值对</span></span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;durian&quot;</span>, []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>&#125;...)</span><br><span class="line">	durianValues := bimap.GetByKey(<span class="string">&quot;durian&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Values for durian:&quot;</span>, durianValues) <span class="comment">// Output: Values for durian: [7 8]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引入线程安全性"><a href="#引入线程安全性" class="headerlink" title="引入线程安全性"></a>引入线程安全性</h2><p>为了带来线程安全性，我们引入了 sync.RWMutex 类型的 lock 字段，并在相应的方法中使用读写锁来保护并发访问。在读取操作 (GetByKey 和 GetByValue) 中，我们使用 RLock 方法获取读锁，并在完成后使用 RUnlock 方法释放读锁。在写入操作 (ResetByKey 和 ResetByValue) 中，我们使用 Lock 方法获取写锁，并在完成后使用 Unlock 方法释放写锁。<br>读锁允许多个 Goroutine 同时访问数据，而写锁会独占地进行写入操作。这样可以提高并发性能并防止数据竞争的发生。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BiMap[K comparable, V comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	forwardMap  <span class="keyword">map</span>[K]<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	backwardMap <span class="keyword">map</span>[V]K</span><br><span class="line">	lock        sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBiMap</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">comparable</span>]<span class="params">()</span></span> *BiMap[K, V] &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BiMap[K, V]&#123;</span><br><span class="line">		forwardMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[K]<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		backwardMap: <span class="built_in">make</span>(<span class="keyword">map</span>[V]K),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> ResetByKey(key K, values ...V) &#123;</span><br><span class="line">	bm.lock.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除原有关联的键值对</span></span><br><span class="line">	oldValues := bm.GetByKey(key)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> oldValues &#123;</span><br><span class="line">		<span class="built_in">delete</span>(bm.backwardMap, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的关联的键值对</span></span><br><span class="line">	bm.forwardMap[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		bm.forwardMap[key][value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		bm.backwardMap[value] = key</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> ResetByValue(value V, key K) &#123;</span><br><span class="line"></span><br><span class="line">	oldKey, ok := bm.GetByValue(value)</span><br><span class="line">	<span class="keyword">if</span> !ok || oldKey == key &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bm.lock.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除原有关联的键值对</span></span><br><span class="line">	<span class="built_in">delete</span>(bm.backwardMap, value)</span><br><span class="line">	<span class="built_in">delete</span>(bm.forwardMap[oldKey], value)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bm.forwardMap[oldKey]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(bm.forwardMap, oldKey)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的关联的键值对</span></span><br><span class="line">	bm.backwardMap[value] = key</span><br><span class="line">	<span class="keyword">if</span> _, ok := bm.forwardMap[key]; !ok &#123;</span><br><span class="line">		bm.forwardMap[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	bm.forwardMap[key][value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> GetByKey(key K) []V &#123;</span><br><span class="line">	bm.lock.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	values, ok := bm.forwardMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]V, <span class="number">0</span>, <span class="built_in">len</span>(values))</span><br><span class="line">	<span class="keyword">for</span> value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> GetByValue(value V) (K, <span class="type">bool</span>) &#123;</span><br><span class="line">	bm.lock.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	key, ok := bm.backwardMap[value]</span><br><span class="line">	<span class="keyword">return</span> key, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync包的不可重入性问题"><a href="#sync包的不可重入性问题" class="headerlink" title="sync包的不可重入性问题"></a>sync包的不可重入性问题</h2><p>此时，重新运行main，程序出现了错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [sync.RWMutex.RLock]:</span><br><span class="line">sync.runtime_SemacquireRWMutexR(0xab3608?, 0x0?, 0xc00007bcd8?)</span><br><span class="line">        .../sdk/go1.21.7/src/runtime/sema.go:82 +0x25</span><br><span class="line">sync.(*RWMutex).RLock(...)</span><br><span class="line">        .../sdk/go1.21.7/src/sync/rwmutex.go:71</span><br><span class="line">main.(*BiMap[...]).GetByKey(0xb63a40, &#123;0xb41e11, 0x5&#125;)</span><br><span class="line">        .../main.go:65 +0x8c</span><br><span class="line">main.(*BiMap[...]).ResetByKey(0xb63a40, &#123;0xb41e11, 0x5&#125;, &#123;0xc00007be70, 0x3, 0x100000000&#125;)</span><br><span class="line">        .../main.go:26 +0xb8</span><br><span class="line">main.main()</span><br><span class="line">        .../main.go:93 +0xdd</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这可能让人非常困惑。通过仔细阅读错误消息，我们可以发现，在已经持有写锁的情况下尝试获取读锁时发生了死锁（同样地，在已经持有读锁的情况下尝试获取写锁也会失败）。显然，Golang的原生互斥锁并不支持重入。</p>
<h3 id="官方文档解释"><a href="#官方文档解释" class="headerlink" title="官方文档解释"></a>官方文档解释</h3><p>深入研究后，我在官方文档的这个链接 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14670979/recursive-locking-in-go/14671462#14671462">https://stackoverflow.com/questions/14670979/recursive-locking-in-go/14671462#14671462</a> 找到了一些解释。</p>
<blockquote>
<p> the best way how to implement recursive locks in Go is to not implement them, but rather redesign your code to not need them in the first place. It’s probable, I think, that the desire for them indicates a wrong approach to some (unknown here) problem is being used.</p>
</blockquote>
<blockquote>
<p>Recursive (aka reentrant) mutexes are a bad idea.<br>The fundamental reason to use a mutex is that mutexes<br>protect invariants, perhaps internal invariants like<br><code>p.Prev.Next == p for all elements of the ring,&#39;&#39; or perhaps external invariants like </code>my local variable x is equal to p.Prev.’’<br>Locking a mutex asserts <code>I need the invariants to hold&#39;&#39; and perhaps </code>I will temporarily break those invariants.’’<br>Releasing the mutex asserts <code>I no longer depend on those invariants&#39;&#39; and </code>If I broke them, I have restored them.’’</p>
</blockquote>
<h2 id="解决不可重入性问题"><a href="#解决不可重入性问题" class="headerlink" title="解决不可重入性问题"></a>解决不可重入性问题</h2><p>现在当我们在一个互斥锁已经被持有的情况下尝试再次获取该锁时，会导致死锁。为了解决这个问题，我们需要重新设计代码，避免对互斥锁的重入需求。</p>
<p>一种常见的方法是使用更细粒度的锁。例如，对于我们的BiMap实现，我们可以使用两个独立的互斥锁来分别保护键到值的映射和值到键的映射。这样，当我们在一个映射上持有锁时，仍然可以在另一个映射上进行操作而不会导致死锁。</p>
<p>另一种方法是重新考虑代码逻辑，避免在持有锁的情况下调用可能导致死锁的函数。这可能需要对代码进行一些重构，以避免重入需求。</p>
<p>这里我们选择用简单的方案，重写 ResetByKey ResetByValue，使他们不在调用 GetByKey GetByValue 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func (bm *BiMap[K, V]) ResetByKey(key K, values ...V) &#123;</span><br><span class="line">	bm.lock.Lock() // 获取写锁</span><br><span class="line">	defer bm.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	// 删除原有关联的键值对</span><br><span class="line">	oldValues := bm.forwardMap[key]</span><br><span class="line">	for value, _ := range oldValues &#123;</span><br><span class="line">		delete(bm.backwardMap, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 添加新的关联的键值对</span><br><span class="line">	bm.forwardMap[key] = make(map[V]struct&#123;&#125;)</span><br><span class="line">	for _, value := range values &#123;</span><br><span class="line">		bm.forwardMap[key][value] = struct&#123;&#125;&#123;&#125;</span><br><span class="line">		bm.backwardMap[value] = key</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bm *BiMap[K, V]) ResetByValue(value V, key K) &#123;</span><br><span class="line">	bm.lock.Lock() // 获取写锁</span><br><span class="line">	defer bm.lock.Unlock()</span><br><span class="line">	</span><br><span class="line">	oldKey := bm.backwardMap[value]</span><br><span class="line">	if oldKey == key &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 删除原有关联的键值对</span><br><span class="line">	delete(bm.backwardMap, value)</span><br><span class="line">	delete(bm.forwardMap[oldKey], value)</span><br><span class="line">	if len(bm.forwardMap[oldKey]) == 0 &#123;</span><br><span class="line">		delete(bm.forwardMap, oldKey)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 添加新的关联的键值对</span><br><span class="line">	bm.backwardMap[value] = key</span><br><span class="line">	if _, ok := bm.forwardMap[key]; !ok &#123;</span><br><span class="line">		bm.forwardMap[key] = make(map[V]struct&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	bm.forwardMap[key][value] = struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BiMap[K comparable, V comparable] <span class="keyword">struct</span> &#123;</span><br><span class="line">	forwardMap  <span class="keyword">map</span>[K]<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	backwardMap <span class="keyword">map</span>[V]K</span><br><span class="line">	lock        sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBiMap</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">comparable</span>]<span class="params">()</span></span> *BiMap[K, V] &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BiMap[K, V]&#123;</span><br><span class="line">		forwardMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[K]<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		backwardMap: <span class="built_in">make</span>(<span class="keyword">map</span>[V]K),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> ResetByKey(key K, values ...V) &#123;</span><br><span class="line">	bm.lock.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除原有关联的键值对</span></span><br><span class="line">	oldValues := bm.forwardMap[key]</span><br><span class="line">	<span class="keyword">for</span> value, _ := <span class="keyword">range</span> oldValues &#123;</span><br><span class="line">		<span class="built_in">delete</span>(bm.backwardMap, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的关联的键值对</span></span><br><span class="line">	bm.forwardMap[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		bm.forwardMap[key][value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		bm.backwardMap[value] = key</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> ResetByValue(value V, key K) &#123;</span><br><span class="line">	bm.lock.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	oldKey := bm.backwardMap[value]</span><br><span class="line">	<span class="keyword">if</span> oldKey == key &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除原有关联的键值对</span></span><br><span class="line">	<span class="built_in">delete</span>(bm.backwardMap, value)</span><br><span class="line">	<span class="built_in">delete</span>(bm.forwardMap[oldKey], value)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(bm.forwardMap[oldKey]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(bm.forwardMap, oldKey)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的关联的键值对</span></span><br><span class="line">	bm.backwardMap[value] = key</span><br><span class="line">	<span class="keyword">if</span> _, ok := bm.forwardMap[key]; !ok &#123;</span><br><span class="line">		bm.forwardMap[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[V]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	bm.forwardMap[key][value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> GetByKey(key K) []V &#123;</span><br><span class="line">	bm.lock.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	values, ok := bm.forwardMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]V, <span class="number">0</span>, <span class="built_in">len</span>(values))</span><br><span class="line">	<span class="keyword">for</span> value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bm *BiMap[K, V])</span></span> GetByValue(value V) (K, <span class="type">bool</span>) &#123;</span><br><span class="line">	bm.lock.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> bm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	key, ok := bm.backwardMap[value]</span><br><span class="line">	<span class="keyword">return</span> key, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bimap := NewBiMap[<span class="type">string</span>, <span class="type">int</span>]()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加键值对</span></span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;apple&quot;</span>, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...)</span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;banana&quot;</span>, []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;...)</span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;cherry&quot;</span>, []<span class="type">int</span>&#123;<span class="number">6</span>&#125;...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取键对应的值</span></span><br><span class="line">	appleValues := bimap.GetByKey(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Values for apple:&quot;</span>, appleValues) <span class="comment">// Output: Values for apple: [1 2 3]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置键对应的值</span></span><br><span class="line">	bimap.ResetByValue(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>)</span><br><span class="line">	updatedAppleValues := bimap.GetByKey(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">	updatedBananaValues := bimap.GetByKey(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Updated values for apple:&quot;</span>, updatedAppleValues)   <span class="comment">// Output: Updated values for apple: [1 3]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Updated values for banana:&quot;</span>, updatedBananaValues) <span class="comment">// Output: Updated values for banana: [4 5 2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新的键值对</span></span><br><span class="line">	bimap.ResetByKey(<span class="string">&quot;durian&quot;</span>, []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>&#125;...)</span><br><span class="line">	durianValues := bimap.GetByKey(<span class="string">&quot;durian&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Values for durian:&quot;</span>, durianValues) <span class="comment">// Output: Values for durian: [7 8]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结与见解"><a href="#总结与见解" class="headerlink" title="总结与见解"></a>总结与见解</h2><p>在本文中，我们讨论了Golang的sync包不支持重入的限制以及相关的问题。</p>
<p>对此，我们应该重新审视代码逻辑，避免在持有锁的情况下调用可能导致死锁的函数。这可能需要对代码进行重构以避免重入需求，并确保正确处理并发访问的情况。</p>
<p>我们都需要选择适当的并发模型和工具来处理并发编程问题的重要性。除了互斥锁外，我们还可以使用其他同步原语或并发安全的数据结构来满足特定的需求。在处理并发编程问题时，需要仔细分析代码，并确保不会引入新的竞态条件或死锁情况。</p>
<p>当然，尽管官方不支持并不提倡重入锁的语义，但仍然有一些开源项目自行实现了支持”可重入”的锁。<br>例如： </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/changsongl/reentrant-lock">https://github.com/changsongl/reentrant-lock</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LgoLgo/geentrant">https://github.com/LgoLgo/geentrant</a></li>
</ul>


  </article>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="busuanzi center">
    page PV:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    site PV:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    site UV:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    
        <style>
        .vcard .vimg{left:0;}
        </style>
        <div id="vcomment" class="vcomment" style="padding:0 6% 0 7%;"></div>
        <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
        <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
        <script>
            var GUEST_INFO = ['nick','mail','link'];
            var guest_info = 'nick,mail,link'.split(',').filter(function(item){
                return GUEST_INFO.indexOf(item) > -1
            });
            var notify = 'false' == true;
            var verify = 'false' == true;
            var valine = new Valine();
            valine.init({
                el: '.vcomment',
                notify: notify,
                verify: verify,
                appId: "EylbFaoiROcSAYFbngyo5eTR-gzGzoHsz",
                appKey: "7oXQjRGMPLzwU8KFGgx6Nvdr",
                placeholder: "请发布你的评论:D",
                pageSize:'10',
                avatar:'mm',
                lang:'zh-cn'
            })
        </script>
    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © Fchange 2016-2024
    </div>
    <div class="secondrow">
        <a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
